I plan to write down my journey while I uncover this old project.
~
Here, I will describe my thinking process while the commits add up over time.
~
The original project's environnement was already provided when I was landed the task to make this Chess game. Thus, the only configuration available was for Windows. I changed that to make sure a building process can be quickly modified for every compatible platform using QMake and Make. I wish to make it automatic in the future. Then, I was still not satisfied with the project's original folder structure, so I separated the source effectively. Another issue I encountered, was the fact that the Qt project is compiled in C++17, but the LSP of my IDE was not parsing the code with that information, and the IDE was also not recognizing the include path of my config. I added a .zed (for the Zed IDE), and a .clangd file (proper to the LSP) to make it work. Those files are local only, since specific to my IDE and OS (XCode tools).
~
I changed the file naming from the original code. This is to prevent errors in Linux servers where filenames may be case sensitive. I also switch all filenames to EN (from FR). I will do the same for the code eventually. In addition, I removed all the include lines to properly remanage the correct location of the logic code, for example, the namespace defintion should be defined in only one place.
~
The project all start inside the main.cpp where a Project object is created. We call show() to start the main loop of the Window panel, thus creating our application (Project inherits QMainWindow). I started by changing the headers. Most changes were simply removing methods that seemed redundant, or functions that were not returning the intended value. For example, in the Board class, with a function, we can get the position of a certain tile. Instead of only the position, it was returning the entire tile. Also, the namespace used was not defined properly; it was defined only once inside another header file where a class was defined, which caused weird pattern of files inclusion throughout the whole project. To fix this, I defined every class in different files inside the same namespace. This allows to only include the partial defintion of namespace classes in the chess_definition file (if we need to know only the type of the variable) while allowing to include the full definition if needed (e.g. rook.h, king.h... needs the full definition of Piece to compile, since inherited). The amount of inclusion files is, at the same time, significantly reduced. including it  In addition, the pieces have private attributes for either the white character or the black character. This isn't good, since we are only defining once if the piece created is white or black at the beginning of the game, and it stays true for the entire duration. That results in a lot of wasted memory space.
~

In order to make better modifications and to understand why I need to improve the program, I need to talk about the main loop. We don't have a lot of control in how the front-end application run the code, how the memory is handled, and which parts. We do have access to an event system and a lot of widgets to manipulate. We can create slots and override methods from QMainWindow to manage mouse interaction for instance. Based on that, the code isn't efficient enough. It is subject of bad practice. To demonstrate, we have options functions, but way too many, they could be reduced to only one. We also have bad program management, like the fact that there is no default option, or the fact that we have technically two boards to manage, from the back and front end. Inside setUp(), a widget is created. This QT object will be the foundation of the chessboard, visually representing all the tiles and the pieces. At the start, we modify the QMainWindow aspect ratio to create a small window. To basically make a widget take up the whole view of the window, setCentralWidget is used. Then, once the options have been chosen and a signal is sent, start() is called. We change the aspect ratio again and the "central" widget. This efectively allows us to create the feeling of switching pages / context. The rest is basically handling the mouse interaction and respecting the behavior of the pieces until the end of the game.
~
In the setUp() function, we create a local variable called menu. We also do that each time we want to set a new central widget (switch page). But doing it that way, we cannot go back from a menu before. If we would like to restart a game right away, we will have to create new widgets instead of using current one. Not great. A good solution would be to create a sort of configuration file that would declare the way the UI is appearing sequentially based on events, and then simply treating that information with a reader that create and manage the menu widgets accordingly. It could be a simple JSON files, with a list of object menus and their associated widgets created. Unfortunately, since we are only working on the chess game, it would be a bit overkill to do that. It would be a great way to configure the game in every aspects, including the size of board, number of tiles, what type of rules. However, I will stick to this implementation structure, even it lacks a bit of maintenability.
~
In the start function of the Project class, we switch menus, create the pieces, set the layout of the board, add each piece to the layout and set the color of the board. This partially done in that order. Before going deeper on the initialization, there is a big issue at hand : what are we storing, and in which classes ? If the player possesses all his pieces, should the pieces be also shared with the tiles associated ? If that's the case, how do keep everything updated ? When a user (player) interacts, do we know which player is interacting, and in the case we know, what's the best way to implement to reduce code duplication ? When a user moves a piece, do we scans the pieces or the entire field of tiles first ? Should we do both ? Do we have all the informations necessary in the specific class we are working on to ensure correct behavior throughout thew whole suration of the game ? I believe it is very hard to formulate a proper response without adressing the rules of the game very concisely. Let's talk about chess.
~
Let's conceptualize with an abstract definition that contains our current class : the game consist of a chessboard comprised of 8 by 8 tiles, two players (W or B) and volatile pieces. Here is a list of additionnal informations that is relevent to us :
-> Each time a correct play is made, we switch to the opposing player
-> Each piece is either associated with the player W or player B
-> Each tile has a fixed position, while each piece doesn't
-> Each piece has a type, and based on its type, it has typed-restrictions on his movements based on its surroundings pieces (relation to tile and piece at the same time)
-> A piece associated with a player can eat a piece associated with the opposing player if within reach
-> The king cannot be move into position it is could be eaten.
-> For a player's turn, his king has to move if the player is in Echec state. If he can't puts himself to protection, he loses, and the other player wins.
This is a well rounded description of the game. I'm going to use it to make deductions on questions we made earlier.
-> To evaluate whether a correct or bad play is made, we need some kind of a request to the system. In a good scenario, assuming we delat with bad scenarios beforehand, we need to 
