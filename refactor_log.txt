I plan to write down my journey while I uncover this old project.
~
Here, I will describe my thinking process while the commits add up over time.
~
The original project's environnement was already provided when I was landed the task to make this Chess game. Thus, the only configuration available was for Windows. I changed that to make sure a building process can be quickly modified for every compatible platform using QMake and Make. I wish to make it automatic in the future, making it possible for every OS to build this project from command line. After that, I was still not satisfied with the project's original folder structure, so I separated the source files effectively. Another issue I encountered, was the fact that the Qt project is compiled in C++17, but the LSP of my IDE was not parsing the code with that information, and the IDE was also not recognizing the include path of my config. I added a .zed (for the Zed IDE), and a .clangd file (proper to the LSP) with my personnal configuration to make it work. Those files are local only, since specific to my IDE and OS (XCode tools).
~
I changed the naming of files from the original like this : place_holder.ext. This is to prevent errors in Linux servers where filenames may be case sensitive. I also switch all filenames to EN (from FR). I will do the same for the code eventually. In addition, I removed all the include lines to properly remanage the correct location of the logic code, for example, the namespace definition should be defined in only one place.
~
The project all start inside the main.cpp where a Project object is created. We call show() to start the main loop of the Window panel, thus creating our application (Project inherits QMainWindow). I started by changing the headers. Most changes were simply removing methods that seemed redundant, or functions that were not returning the seemingly intended value. For example, in the Board class, with a function, we can get the position of a certain tile. Instead of only the position, it was returning the entire tile which doesn't seem right since we have access to the tiles directly. Also, the namespace used was not defined properly; it was defined only once inside another header file where a class was defined, which caused weird pattern of files inclusion throughout the whole project. To fix this, I defined every class in different files inside the same namespace. This allows to only include the partial definition of namespace classes in the chess_definition file (if the compiler needs to know only the type of the variable) while allowing to include the full definition (e.g. rook.h, king.h... needs the full definition of Piece to compile, since inherition). The amount of inclusion files is, at the same time, significantly reduced. including it  In addition, the pieces have private attributes for either the white character or the black character. This isn't good, since we are only defining once if the piece created is white or black at the beginning of the game, and it stays true for the entire duration. That results in a lot of wasted memory space.
~
In order to make better modifications and to understand why I need to improve the program, I need to talk about the main loop. We don't have a lot of control in how the front-end application run the code. Nevertheless, we do have access to an event system and a lot of widgets to create and manipulate. We can create slots and override methods from QMainWindow to manage mouse interaction for instance. Based solely on that, the current code that source from the Project class isn't efficient enough at my taste. It is subject of bad practice. To demonstrate, we have options functions, but way too many, they could be reduced to only one. We also have bad program management, like the fact that there is no default option, or the fact that we have technically two boards to manage, from the back and front end. Inside setUp(), a widget is created. This QT object will be the foundation of the chessboard, visually representing all the tiles and the pieces. At the start, we modify the QMainWindow aspect ratio to create a small window. To basically make a widget take up the whole view of the window, setCentralWidget is used. Then, once the options have been chosen and a signal is sent, start() is called. We change the aspect ratio again and the "central" widget. This efectively allows us to create the feeling of switching pages / context. The rest is basically handling the mouse interaction and respecting the behavior of the pieces until the end of the game.
~
In the setUp() function, we create a local variable called menu. We also do that each time we want to set a new central widget (switch page). But doing it that way, we cannot go back from a menu before. If we would like to restart a game right away, we will have to create new widgets instead of using current one. Not great. A good solution would be to create a sort of configuration file that would declare the way the UI is appearing sequentially based on events, and then simply treating that information with a reader that create and manage the menu widgets accordingly. It could be a simple JSON files, with a list of object menus and their associated widgets created. Unfortunately, since we are only working on the chess game, it would be a bit overkill to do that. It would be a great way to configure the game in every aspects, including the size of board, number of tiles, what type of rules. However, I will stick to this implementation structure, even it lacks a bit of maintenability.
~
In the start function of the Project class, we switch menus, create the pieces, set the layout of the board, add each piece to the layout and set the color of the board. This is partially done in that order. Before going deeper on the initialization, there is a big issue at hand : what are we storing, and in which classes ? If the player possesses all his pieces, should the infos of pieces be also shared with the tiles associated ? If that's the case, how do keep everything updated ? When a user (player) interacts, do we know which player is interacting ? And in the case we do know, what's the best way to implement to reduce code duplication ? When a user moves a piece, do we scans the pieces or the field of tiles first ? Should we do both ? Do we have all the informations necessary in the specific class we are working on to ensure correct behavior throughout thew whole suration of the game ? I believe it is very hard to formulate a proper response without adressing the rules of the game very concisely. Let's talk about chess.
~
Let's conceptualize with an abstract definition that contains our current class : the game consist of a chessboard comprised of 8 by 8 tiles, two players (W or B) and volatile pieces. Here is a list of additionnal informations that is relevent to us :
1. Each time a correct play is made, control goes to the opposing player
2. Each piece is either associated with the player W or player B
3. Each tile has a fixed position, while each piece doesn't
4. Each piece has a type, and based on its type, it has typed-restrictions on his movements based on its surroundings pieces (relation to tile and piece at the same time)
5. A piece associated with a player can eat a piece associated with the opposing player if within reach
6. The king cannot be move into position it is could be eaten.
7. For a player's turn, his king has to move if the player is in Echec state. If he can't puts himself to protection, he loses, and the other player wins.
~
This is a well rounded description of the game. Based on the fact that everytime a click is handled, the only thing we have to work with is the position on the screen where the click happened, I'm going to to make deductions on the previous points respectfully :
1. To evaluate whether a correct or bad play is made, we need some kind of a request to the system. In a good scenario, assuming we dealt with bad scenarios beforehand, the player will click 2 times, one time to select the piece to move, and another time to select the position where he want to move that piece. If that sequence is correctly done + the position he wants to move is possible (check tile and pieces), then we can switch the player's turn. The turn phase mean that the current player and opposing are switched.
2-3. Pieces are represented by their character, identifiable based on the Player. Player are represented by their own Pieces. There is a clear circular dependancy here, so we need to create the objects separately, and attach the pointer inside each class efficiently. Another thing: Tiles are represented by either a Piece or nothing. This means that the positions of Tiles and Pieces need to be evaluated exactly before and after user interaction, so we ensure th behavior of interactions during the right turn of the Player. This whole point proves that using shared_ptr is probably the best way to handle synchronisation in all the classes created. So the creation of all objects should be made in the constructor of Project, and in the start() fucntion, all the pointers of all the object should bet set. Doing that, we cannot initialize any pointer in the constructor of any other class (Board, Player, Piece..), because they all need to be created before their adress being assigned to another object. So this is a big modification to act on the current impl.
4. This is relative to the prediction of movements. We can deduct the same as the previous point, with the addition that the entire field of Tiles needs to be available in order to calculate the possibles Tiles to move for any selected piece.
5-6-7. This part helped me deduct that crucial verififcations need to be done before the computing of valid movements and the possible movements of the board pieces for each Player for the state of the King (I should call this the next step prediction state). Missing informations in classes or bad initialization of shared_ptr would render very hard the developpement of the game. The current implementation of this is hard to understand because nothing actually represent these verifications abstractions. They are only done in methods inside different class, encapsulated in condition checks that are not methods. The complexity rises, and the refactoring, in this sphere of the behavior, becomes very complex.
~
I'm going to take a pause here from the deductions, because all these elements previously treated have let me seen something that needs rectifying. In all the methods inside the main class, there is no call made to the array of tiles with the format array access operator ([][]). But inside the children of the piece class, we use it. I think this is a design flaw, where at the beginning, the intention was to use a 2D board of tiles to acces the tiles corresponsingly and calculate the correst moves for each piece, but at the end, we ended up not having to use efficiently, since we had to add the positions member inside different classes to compare with the mouse event data given by QT. I decided to delete the Board class, since it was encapsulating only a member that I figure deprecated from now on. Now piece will use their own position, and be given an array of tiles to understand the current (at t time) context of the board.
~
To resume, right now, the responsability of handling the game is on the player, not the pieces. Player class has mutliple methods for that. The Piece class can handle finding the position of their next play based on the context given at the instant we call his methods, and the child appropriate methods. This is fine, but there is something that has been bugging me since the beginning. In Player methods, in the parameters, we see both the own players pieces and the opposing players pieces being handled. This is kind of wrong, since both players can manage the pieces, technically we only need one Player to manage. Adding another player would only serve to show the name at the end of the game, in addition to the result. So since this is the case, I will change the Player class into a GameManager, that will pass in the methods parameters the entire pieces set, since the informations about the color of the pieces is inside each of them, and also the entire tile set, because we can compare the position of the pieces and the tiles effectively. Doing that, we wont have to ensure the Player members are correctly updated, and we won't have to ask why pieces are inside Player if we already have access to it in Project. Doing that will reduce immensely the complexity.
~
I have been struggling to find the best way to make use of the shared_ptr. Since I already see how the implementation make use of the functions in the classes to pass the tiles and corresponding pieces, I found it hard to find the utility of sharing the pieces and tiles to the classes, because most of the times, we only need to read them and interpret a return response. So I took the liberty of defining a unique_ptr to each Tile, that points to a Piece, since only one Piece can be at the same position of a single Tile. Doing that, I broke the abstraction of the Piece classl. This means that I must implement the virtual methods that were present. I thought I couln't because I needed to know what type of piece they are to implement validMoves, which return the tile where the piece can move to. But the thing is, the implementation is the same for every pieces: they have certain direction they can go, for infinity until they reach a piece, or not. For example, the queen has all 8 possible directions to move around her and can go to infinity until she reaches another piece, while its the same for the king except he can only move one tile. Even the knight can be applied the same logic, but with a little twist. The direction of the knight will have a component doubled (like [] or []) instead of the others. That will point him to the right direction and validate his movements with the same logic as the other one, allowing me to modify this class into not an abstraction anymore, since the logic will the same for every class. I just need to add checks to verify the directions and the possible infinity movement until piece reach.
~
A lot of changes have been made. To sum up, the logic behavior of adding pieces to tiles has been move to the Manager, and a unique_ptr is now used to store a piece inside a tile to better represent ownership. That leaves only a a vector of shared_ptr of tiles present in the Project class, waiting to be fully exploited later. By the way, I created a typedef Tiles for better readability, so Tiles = vector<shared_ptr<Tile>>. Also, the entire creation of pieces was made in the constructor, because I plan in the future to create a configuration file that will process it in single loop all the pieces initialization + storing their unique_ptr in the right place.
~
Now, the manager has been created and some functions have been instaured, the functon getValidMoves in Piece has been implemented as well to accomodate all situations, for the ennemies and allies, and few tweaks in the styles sheet have been made. We also succeeded in reducing the number of lines in each classes. I wouldn't say there was a lot of code duplication, but I think a lot of behavior handling was taking double effort and ressources to provide the same result. For example, in the previous implementation, to just verify if the tile that is in a certain position in the board owns a piece or not, we had to take the position of the tile, and compare it to a list of piece using a loop. We often found ourselves in O(nË†2) scenarios instead of simply O(n). This has significantly improved performance. Now, the ownership from a piece is transfered to a new tile everytime we allow it to move, making it impossible have two of the same piece exist at the same time. This allows the verifications for the end game, which I will need to implement, to not let inconsistencies rule the predictions made at any moment in the interaction loop with the client.
~
Before going straight to the end game, I need to set some keys in methods in the manager to properly debug. I need to access all the pieces and each of their valid moves. Then, for the duration of only the press of a keyboard button (from press to release), I need to show on the screen the tiles affected. This will allow me to verify a few things : first, that the King cannot move to a position where he can be eaten, and secondly that, if in a situation of check, the King can be protected no matter what. The first verification doesn't require much since we have all the necessary methods to help us, but the second one will be a bit more difficult, because we will need to simulate every validMove. Simulation means more than just looking up these tiles, it means pretending we move to each valid tile with the corresponding piece, which is something difficult since I have detached the some important cohesion of the pieces with the tiles for the benefit of other solutions. But once this part is figured out, I will conclude my refactor process with some analysis and conclusions. To explain the endgame phase, there is an "endgame_decision.png" image in the assets of the project folder to help understand the behavior. To infer quickly, the situation is tricky because of the relations between the timing of interactions and some conclusions of the verifications. For instance, when traversing the flowchart and answering only Yes, we arrive at a conclusion that we need to verify if other pieces than the King in CHECK state can threathens the King of the other player. That said, we could recall the verifications in a recursing order, but we have to be careful because if we do that this way, both player could arrive at the in a situation of simulating back and forth the same move, and we would have an infinite loop. Instead of that, I won't do recursive call, but simply verify if the validTiles of a single piece after simulation threatens the position of the other King. ... Let's take a brief pause here. I am conscious that the explanation that I just gave is not something easy to understand, not because of complexity of the description, but simply because of readability. I admit that. However, this is kind of how the code is going to translate. The verification is going to happen in the manager_ just inside the move method. Before going further, I also want to say that the original code that was present did behave in the same way, but omitted some important conclusion (see engame_decision.png) like the simulation of all pieces for potential protection. Also, the previous code had a problem of timing. All the verifications I mentionned here needs to two conditions to be true before happpening : the second clic happens, and a piece was moved (changing the context of board). That's right, the timing is extremely important. By functionning this way, we only authorize to change the actual situation/context of the board at a single moment in, which is when moving a piece. This is not how the previous implementation works, because some checks were relationnal to how a piece moved before or after a click, which can be evaluated at different time. And finally (last part), we indeed need to check the opponent's King, but also the current player's King too (endgame_decision2.png). Nevertheless, the verification is way less deep than what I explained, because we only need to check once if the move (from any piece) that is done put the King in danger. So only one simulation from the selected tile to the chosen tile is required, instead of N simulations (number of pieces).
