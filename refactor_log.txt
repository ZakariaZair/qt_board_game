I plan to write down my journey while I uncover this old project.
~
Here, I will describe my thinking process while the commits add up over time.
~
The original project's environnement was already provided when I was landed the task to make this Chess game. Thus, the only configuration available was for Windows. I changed that to make sure a building process can be quickly modified for every compatible platform using QMake and Make. I wish to make it automatic in the future. Then, I was still not satisfied with the project's original folder structure, so I separated the source effectively. Another issue I encountered, was the fact that the Qt project is compiled in C++17, but the LSP of my IDE was not parsing the code with that information, and the IDE was also not recognizing the include path of my config. I added a .zed (for the Zed IDE), and a .clangd file (proper to the LSP) to make it work. Those files are local only, since specific to my IDE and OS (XCode tools).
~
I changed the file naming from the original code. This is to prevent errors in Linux servers where filenames may be case sensitive. I also switch all filenames to EN (from FR). I will do the same for the code eventually. In addition, I removed all the include lines to properly remanage the correct location of the logic code, for example, the namespace defintion should be defined in only one place.
~
The project all start inside the main.cpp where a Project object is created. We call show() to start the main loop of the Window panel, thus creating our application (Project inherits QMainWindow). I started by changing the headers. Most changes were simply removing methods that seemed redundant, or functions that were not returning the intended value. For example, in the Board class, with a function, we can get the position of a certain tile. Instead of only the position, it was returning the entire tile. Also, the namespace used was not defined properly; it was defined only once inside another header file where a class was defined, which caused weird pattern of files inclusion throughout the whole project. To fix this, I defined every class in different files inside the same namespace. This allows to only include the partial defintion of namespace classes in the chess_definition file (if we need to know only the type of the variable) while allowing to include the full definition if needed (e.g. rook.h, king.h... needs the full definition of Piece to compile, since inherited). The amount of inclusion files is, at the same time, significantly reduced. including it  In addition, the pieces have private attributes for either the white character or the black character. This isn't good, since we are only defining once if the piece created is white or black at the beginning of the game, and it stays true for the entire duration. That results in a lot of wasted memory space.
~
In order to make better modifications and to understand why I need to improve the program, I need to talk about the main loop. We don't have a lot of control in how the front-end application run the code. Nevertheless, we do have access to an event system and a lot of widgets to create and manipulate. We can create slots and override methods from QMainWindow to manage mouse interaction for instance. Based solely on that, the current code that source from the Project class isn't efficient enough at my taste. It is subject of bad practice. To demonstrate, we have options functions, but way too many, they could be reduced to only one. We also have bad program management, like the fact that there is no default option, or the fact that we have technically two boards to manage, from the back and front end. Inside setUp(), a widget is created. This QT object will be the foundation of the chessboard, visually representing all the tiles and the pieces. At the start, we modify the QMainWindow aspect ratio to create a small window. To basically make a widget take up the whole view of the window, setCentralWidget is used. Then, once the options have been chosen and a signal is sent, start() is called. We change the aspect ratio again and the "central" widget. This efectively allows us to create the feeling of switching pages / context. The rest is basically handling the mouse interaction and respecting the behavior of the pieces until the end of the game.
~
In the setUp() function, we create a local variable called menu. We also do that each time we want to set a new central widget (switch page). But doing it that way, we cannot go back from a menu before. If we would like to restart a game right away, we will have to create new widgets instead of using current one. Not great. A good solution would be to create a sort of configuration file that would declare the way the UI is appearing sequentially based on events, and then simply treating that information with a reader that create and manage the menu widgets accordingly. It could be a simple JSON files, with a list of object menus and their associated widgets created. Unfortunately, since we are only working on the chess game, it would be a bit overkill to do that. It would be a great way to configure the game in every aspects, including the size of board, number of tiles, what type of rules. However, I will stick to this implementation structure, even it lacks a bit of maintenability.
~
In the start function of the Project class, we switch menus, create the pieces, set the layout of the board, add each piece to the layout and set the color of the board. This is partially done in that order. Before going deeper on the initialization, there is a big issue at hand : what are we storing, and in which classes ? If the player possesses all his pieces, should the infos of pieces be also shared with the tiles associated ? If that's the case, how do keep everything updated ? When a user (player) interacts, do we know which player is interacting ? And in the case we do know, what's the best way to implement to reduce code duplication ? When a user moves a piece, do we scans the pieces or the field of tiles first ? Should we do both ? Do we have all the informations necessary in the specific class we are working on to ensure correct behavior throughout thew whole suration of the game ? I believe it is very hard to formulate a proper response without adressing the rules of the game very concisely. Let's talk about chess.
~
Let's conceptualize with an abstract definition that contains our current class : the game consist of a chessboard comprised of 8 by 8 tiles, two players (W or B) and volatile pieces. Here is a list of additionnal informations that is relevent to us :
1. Each time a correct play is made, control goes to the opposing player
2. Each piece is either associated with the player W or player B
3. Each tile has a fixed position, while each piece doesn't
4. Each piece has a type, and based on its type, it has typed-restrictions on his movements based on its surroundings pieces (relation to tile and piece at the same time)
5. A piece associated with a player can eat a piece associated with the opposing player if within reach
6. The king cannot be move into position it is could be eaten.
7. For a player's turn, his king has to move if the player is in Echec state. If he can't puts himself to protection, he loses, and the other player wins.
~
This is a well rounded description of the game. Based on the fact that everytime a click is handled, the only thing we have to work with is the position on the screen where the click happened, I'm going to to make deductions on the previous points respectfully :
1. To evaluate whether a correct or bad play is made, we need some kind of a request to the system. In a good scenario, assuming we dealt with bad scenarios beforehand, the player will click 2 times, one time to select the piece to move, and another time to select the position where he want to move that piece. If that sequence is correctly done + the position he wants to move is possible (check tile and pieces), then we can switch the player's turn. The turn phase mean that the current player and opposing are switched.
2-3. Pieces are represented by their character, identifiable based on the Player. Player are represented by their own Pieces. There is a clear circular dependancy here, so we need to create the objects separately, and attach the pointer inside each class efficiently. Another thing: Tiles are represented by either a Piece or nothing. This means that the positions of Tiles and Pieces need to be evaluated exactly before and after user interaction, so we ensure th behavior of interactions during the right turn of the Player. This whole point proves that using shared_ptr is probably the best way to handle synchronisation in all the classes created. So the creation of all objects should be made in the constructor of Project, and in the start() fucntion, all the pointers of all the object should bet set. Doing that, we cannot initialize any pointer in the constructor of any other class (Board, Player, Piece..), because they all need to be created before their adress being assigned to another object. So this is a big modification to act on the current impl.
4. This is relative to the prediction of movements. We can deduct the same as the previous point, with the addition that the entire field of Tiles needs to be available in order to calculate the possibles Tiles to move for any selected piece.
5-6-7. This part helped me deduct that crucial verififcations need to be done before the computing of valid movements and the possible movements of the board pieces for each Player for the state of the King (I should call this the next step prediction state). Missing informations in classes or bad initialization of shared_ptr would render very hard the developpement of the game. The current implementation of this is hard to understand because nothing actually represent these verification abstraction. They are only done in methods inside different class, encapsulated in condition checks. The complexity rises, and the refactoring in this sphere of the behavior is very time-consuming...
~
I'm going to take a pause here from the deductions, because all these elements previously treated have let me seen something that needs rectifying. In all the methods inside the main class, there is no call made to the array of tiles with the format array access operator ([][]). But inside the children of the piece class, we use it. I think this is a design flaw, where at the beginning, the intention was to use a 2D board of tiles to acces the tiles corresponsingly and calculate the correst moves for each piece, but at the end, we ended up not having to use efficiently, since we had to add the positions member inside different classes to compare with the mouse event data given by QT. I decided to delete the Board class, since it was encapsulating only a member that I figure deprecated from now on. Now piece will use their own position, and be given an array of tiles to understand the current (at t time) context of the board.
~
To resume, 